![Screen Shot 2021-03-22 at 6 57 07 PM](https://user-images.githubusercontent.com/5890251/112081188-7ca09a80-8b40-11eb-9292-d84859580877.png)
### Overview 
1. Advanced Docker Concepts Lecture


#### What is Docker?  
1. ```docker run image ``` runs an image which is locally saved (cached) in your machine. If it can't find that image in your machine, it looks for one in Dockerhub, downloads to your machine, and spins up a container from that image.
2. ```Dockerhub``` is where people upload```image``` for everyone to use. 
3. An ```image``` is the perfect sandwich. ```images``` are created with a ```build``` command, they produce a ```container``` when started with ```run```. 
4. The clones of ```image``` or a perfect sandwich is the ```container```. You can spin up as many containers from an image as you want without affecting the perfect sandwich. 
5. ```docker run image```does two things: 
     - ```docker images``` downloads image from dockerhub if it doesn't exist in your local machine
     - ```docker ps -a``` displayes all the containers in your machine.
     - ```-a``` flag displays all the containers running and stopped, whereas ```docker ps -a``` only displays running containers. 
6. Spinning a brand new ```container``` with a brand new ```image```: ```docker run -d -p 80:80 --name webserver nginx```
     - ```docker run``` creates a new container from an image.
     - ```nginx``` the name of the image to spin into a container.
     -  ```--name webserver``` gives the container a unique name to indentify it
     -  ```-p 80:80``` connect port 80 on the host to port 80 on the container.
     -  ```d``` runs your container in a detached state, meaning it runs in the background.
7. ```docker stop webserver``` to stop a container called webserver.
8. ```docker start webserver``` to start a container called webserver.
9. ```docker rm webserver``` to remove a container. Note, container has to be stopped to be removed. ```docker rm conatinerx containery``` to remove multiple containers at once.
10. ```docker rm -f webserver``` to force a running container to be removed. 
11. ```docker run -d -p 80:80 -rm --name goodbye nginx``` builds a container called goodbye from image called nginx and when ```docker stop goodbye``` it gets removed on its own. 
12. ```docker rmi imagename``` to remove an image. Note, remove containers before removing images. 
13. ```docker images``` to see all the images in your machine. 
14. ```docker info``` to get a status report of all the images and containers in your machine. 

#### Containerize your app with Docker
1. Dockerfile is the receipe that image (aka perfect sandwich) uses. 
2. To build an image from scratch that could be spun into a container that runs node.js:  
      -  Build from Ubuntu image > 
      -  Update Ubuntu > 
      -  Install Node > 
      -  Add Working Directory > 
      -  Copy app into working Directory > 
      -  Install Dependencies
3. ```docker pull node:latest``` to see the latest node image. ```docker history image_name:latest``` to see the history of how that image was built. 
4. What is inside Dockerfile
     ###### What image do you want to start building on?
     ```FROM node:latest```

     ###### Make a folder in your image where your app's source code can live
     ```RUN mkdir -p /src/app```
     ```-p``` makes all the necessary parent folders automatically. 
     
     ###### Tell your container where your app's source code will live
     ```WORKDIR /src/app```
     
     ###### What source code do you what to copy, and where to put it?
     ```COPY . /src/app```
     ```.``` where to copy the app's souce code from.
     ```/src/app``` where the source code from our app is going to be copied to in the image. 
     ###### Does your app have any dependencies that should be installed?
     ```RUN npm install```

     ###### What port will the container talk to the outside world with once created?
     ```EXPOSE 3000```
     Exposes container's port 3000.
     
     ###### How do you start your app?
     ```CMD ["npm", "start"]```

5. ```docker build -t nodeserver```
      - ```docker build``` takes Dockerfile and creates and image using the info from inside
      - ```-t``` the t stands for tagged
      - ```.``` the relative path to the Dockerfile that we want to build into an image
6. Containers are stateless. 
7. ```docker run -d -p 1000:3000 --name slytherin_rulez --rm nodeserver``` to run the container on your localhost port 1000. 
      - ```rm``` flag deletes the container when you stop running the container. 
      
### Containerized Development with Volumes

1. Steps to containerization (?) 
     - Bundle your app into an image, give it a name ```colorserver```. 
          ```docker build -t colorserver .```
     - Spin up a new container based on ```colorserver``` image, map it to port 8080 on the host. 
          ```docker run -d -p 8080:8080 colorserver```
     - Open localhost:8080 to checkout the webpage. The color is steelblue for now. 
     - Since this is dev mode, Let's say you want to change the color to green, when you make the change, you want your container to also reflect that change, we do this using Volumes
     - Volumes allow containers tointeract with the host's filesystems. Useful in persisting data, and as a communication between otherwise isolated containers, and have our container reference rapidly changing source code on our host. 
     - Using ```-v``` option, you can mount a volume. ```-v``` takes two arguments. 
     - First argument is the path to directory that you want spun-up container to reference. 
     - Second argument is the path to directory inside the container where you want those file changes to be reflected (separated by a colon :) 
     - ```docker run -d -p 1000:8080 -v /Users/kanchanchauhan/Documents/sei/docker/Please-Contain-Yourself/4-Containerized_Development_With_Volumes/:/src/app --name psychic_container colorserver```
     - ```$(pwd)``` can be used instead of ```/Users/kanchanchauhan/Documents/sei/docker/Please-Contain-Yourself/4-Containerized_Development_With_Volumes```.
 
 ##### Takeaway: With a Dockerfile (receipe), you just need to build an image from this dockerfile, then the image can be spun into a container with a dev env identical to the one you used. You can then spin a container by mounting a volume with the source code. 
 
Note: ```docker logs <container_name>``` shows everything that has been logged inside the container so far.

![Screen Shot 2021-03-22 at 3 51 40 PM](https://user-images.githubusercontent.com/5890251/112068103-7f8e9180-8b26-11eb-8d38-4dd85d6fa557.png)

#### Make Multiple Containers Work Together

- Containers can be used to organize our app into microservices.
- Container is the smallest unit of real composition. It's a good idea to have one microservice in one container. 
- Microservice architecture breaks our app into a set of independent services that are developed, deployed, maintained separately. 
     - allows our microservice to be scaled differently. Spinning up more containers allow us to scale horizontally. 
     - allow us to build software that is adaptable, composable, autonomous and fault tolerant.

##### HOW TO MAKE CONTAINERS TALK TO EACH OTHER 

1. Build images 
    1. For each microservice, run ```docker build -t survey .```
    2. For mongodb, pull an image by running ```docker pull mongo:latest``` * this is one way of building image with configuring anything. The above process is when you want to configure your image. Note ```docker pull``` gets an image from Dockerhub and caches it in your machine. 
2. Run the containers
   1. ```docker run -d --name mongo mongo:latest```
3. Don't forget to mount volumnes (the following command runs and mounts volumes at the same time):
   1. ```docker run -d -p 8080:8080 -v $(pwd):/src/app --name app_container app```
4. Next, Docker networking (kind of like the internet only Docker containers can use, you can many isolated networks too..so that a group of containers can only talk to each other..)
   1. ```docker network ls``` docker comes with three networks already installed. Bridge is the network all our containers so far have by default been residing.
   
   ![Screen Shot 2021-03-22 at 4 38 06 PM](https://user-images.githubusercontent.com/5890251/112071442-fe86c880-8b2c-11eb-8cb0-70f79551de5b.png)

   2. ```docker network inspect <network_name> ``` gives you an overview of all the containers in that network.

   ![Screen Shot 2021-03-22 at 1 12 31 PM](https://user-images.githubusercontent.com/5890251/112071586-51608000-8b2d-11eb-9ba3-d055bce7a726.png)

   Note: All containers that want to talk to each other need to be in the same network. 
   
   In this example, mongo - results_container - survey_container are all inside bridge network. Change the server that the server is trying to connect to Mongo Database with. ```mongodb://localhost:27017/docker_test``` becomes ```mongodb://172.17.0.2:27017/docker_test```
   
   ![Screen Shot 2021-03-22 at 4 45 47 PM](https://user-images.githubusercontent.com/5890251/112071946-0eeb7300-8b2e-11eb-9aec-8bcf6f252ec9.png)
  

### DOCKER COMPOSE FOR MULTI CONTAINER APPS

1. ```docker-compose up``` runs the ```docker-compose.yml``` file. 
2. In the process of running ```docker-compose up```, compose ended up creating 
   1. new images 
   2. new containers 
   3. new network to host our microservices
   4. When you run ```docker-compose up -d``` again, it reused images, containers it had created the first time ```docker compose up``` was run. Note ```-d``` has nothing to do with this speed, it just runs our app in the background. 
   5. ```docker-compose down```stops our app's containers, removes containers, removes network (BUT NOT IMAGES).
   6. ```docker-compose dowm -rmi all``` removes everything including images. 
   

### USING DOCKER FOR REVIEWS

1. Create a ```dockerfile``` inside the folder containing microserver that you want to create images for. 

![Screen Shot 2021-03-22 at 6 32 57 PM](https://user-images.githubusercontent.com/5890251/112079248-10706780-8b3d-11eb-8504-846692811418.png)

2. Create a ```docker-compose.yml``` at the root directory level (meaning outside the folder containing ```dockerfile```.

![Screen Shot 2021-03-22 at 6 34 42 PM](https://user-images.githubusercontent.com/5890251/112079380-49104100-8b3d-11eb-9d95-31dedcbacb9e.png)

3. Make sure package.json you are running npm install for is inside the microservice folder. I had to make sure to include my data folder inside my microservice folder. 

4. Run ```docker-compose up``` to run ```docker-compose.yml``` file. 

5. This creates images, containers and network needed to run your microservice. 

6. Run ```docker exec -ti reviews_database_1 bash``` to access bash terminal. 
     - access mysql by running ```mysql -u root --local_infile```
     - ![Screen Shot 2021-03-22 at 6 32 49 PM](https://user-images.githubusercontent.com/5890251/112080859-ee2c1900-8b3f-11eb-9c3c-4b3c50555e2e.png)

     - ![Screen Shot 2021-03-22 at 6 08 11 PM](https://user-images.githubusercontent.com/5890251/112080856-eb312880-8b3f-11eb-9253-d504201a0e5f.png)
     
     This is how my file structure 
     
     - ![Screen Shot 2021-03-22 at 6 54 26 PM](https://user-images.githubusercontent.com/5890251/112080938-0f8d0500-8b40-11eb-9e99-c4515a779f52.png)
     

